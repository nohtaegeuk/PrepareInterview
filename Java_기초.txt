＜１＞

Java - 한국에서는 시스템 통합 프로젝트가 대부분 자바로 구현.

시스템이란, 기관이나 기업의 업무 관리를 소프트에어화 하는 것을 의미.

>> 이렇기 때문에 굉장히 큰 시장을 끼고있음.

또한 안드로이드의 성공과 더불어 더 중요시하게 됨.


자바 참고 자료 - 1. 자바 홈페이지

2. 난 정말 자바를 공부한 적이 없어요 - 무료

3. 소설 자바 - 무료

4. 점프 투 자바


학습방법 - 학습을 빠르게 하고 실습은 천천히 느리게 차근차근


＜２＞

프로그래밍을 한다 : 코드를 작성한다.

code = source를 작성한다.

설계도를 작성한다.


프로그램을 만들 때도 설계도를 작성하여야 한다. 프로그래머도 이해해야 하지만 다른사람이 봐도 이해할 수 있어야 한다. 소스코드를 작성하게 되면 작성한데로 컴퓨터가 작성해준다. 생각한데로 만들어 주는 것이 다른 분야의 사업과 다른점이다.


존재하지 않는 이미지입니다.









우리는 소스코드를 작성하게 되고, 그것을 자바가 운영체제에 있는 자원들을 바탕으로 실행하게 된다. 소스코드를 작성해서 자신이 원하는 프로그램을 만들기 위해서는 자바를 설치해야함.

용어 - Java SE , JDK, JRE

Java SE - 자바의 표준안.

JDK - 자바를 개발하는데 필요한 도구들의 모임. Java Development Kit. 개발자를 위한 것.

JRE - 자바로 만들어지 프로그램이 구동되기 위한 환경을 제공. Java Runtime Environment

JRE는 JDK안에 포함되어 있음. JRE는 일반인을 위한 것.


JVM - Java Virtual Machine 가상 컴퓨터. 우리가 작성한 코드가 JVM위에서 돌아가게 됨.


< 7 >


코드 : class Helloworld{

public static void main(String[] args){

System.out.println("Hello world");

}

}


　 이것의 파일 이름은 helloworld.java 이다.

컴파일 : 코드는 사람만 이해할 수 있음. 컴퓨터는 2진법만 이해할 수 있다.

컴퓨터가 이해할 수 있는 방식으로 변환하는 것을 말함.

즉 코드를 컴퓨터가 이해할 수 있는 바이트코드로 전환해주는 과정을 말함.

이 과정을 하는 소프트웨어를 컴파일러 라고 함. (ex, javac)


존재하지 않는 이미지입니다.

실행 : Helloworld.class라는 파일이 생성이 되면, 파일이 기술된 대로 실행하는 것.


흐름..




< 10 >


윈도우는 메모장 만으로도 충분히 코딩이 가능하다.




< 11 >

이클립스 - 가장 대표적인 자바의 개발도구. 통합 IDE라고 불리는 소프트웨어.

오픈소스이며, 무료, 모든 운영체제를 지원.

< 15 >

package explorer : 우리의 프로젝트를 관리하는 도구


outline : 소스코드에는 여러 가지 문법요소가 있는데 어떤 요소들로 이 프로그램이

구성되어있는지 보여주고 자신이 필요로 하는 것을 빠르게 찾게 해주는 것.


problems : 소스코드에 문제가 있을 때 알려주는 것.


console : 출력된 결과가 console 이라는 뷰를 통해 출력


view : 소스코드를 실제로 작성하는 에디터


debug : 버그를 잡는 것.


debuger : 버그를 잡을 때 필요한 툴


src : source의 약자 .java라는 확장자를 가지고 있음


bin : binary의 약자 .class 로 끝나는 파일


우리가 작성한 코드는 src에 저장이됨.

이클립스를 통해 컴파일된 파일은 bin에 저장됨.

소스와 실제 에플리케이션(실행파일)이 src와 bin디렉토리에 분산되서 저장됨.



< 18 >

데이터 타입 : 데이터 형식. 자료형 이라고 부름.

새로운 package 만드는 법 :src - NEW - package

class 이름 지을 때 public 체크하기


1, 2, 1.2, 1.3 즉, 자바에 따옴표가 없는 숫자는 숫자로 인식.

따라서 ()안에 1+2를 넣으면 결과값인 3이 출력됨.


문자라는 것은 A, B / 문자열은 문자와 문자의 결합 AB를 말함.

문자는 Character 문자열은 String 이라고 함.

ex) 생 : 문자

생활코딩 : 문자열

* 문자는 작은 따옴표(‘)로 감싸야 하고 문자열은 큰따옴표(“)로 감싸야 한다.

ᄒᆞᆫ의 문자를 큰 따옴표로 감싼다고해서 에러가 발생하지는 않는다.

한 글자도 문자열이 될 수 있기 때문.

\를 “앞에 위치시키면 ”를 문자열의 시작과 끝을 구분하는 문자가 아니라 단순히 문자로

해석하도록 강제할 수 있다.


\뒤에 n이 오게 되면, /n 은 줄바꿈을 의미



< 19 >

변수 : 변할 수 있는 값. 즉 변할 수 있는 데이터. Variable을 의미.

여기에 담겨진 데이터는 다른 데이터로 바꿀 수 있다.


int a 는 변수를 만드는 구문. 즉 변수를 선언한 것.

int 는 데이터의 형식. a는 변수의 이름.

int라는 것은 integer의 줄임말.

int a 는 a라는 변수에 담길 수 있는 것은 숫자입니다 라는 것을 의미.



< 20 >

자바는 섬세한 언어라서 정수와 실수를 구분해야 하며, 선언하는 방법도 다름.

정수 선언 방법 : int / 실수 선언 방법 : double



< 21 >

first를 문자를 담을 수 있는 변수로 만들려면 String을 사용해야함.

변수를 선언하는 것과 변수를 할당하는 것은 한줄로 할 수 있음.

String = first;

first = "coding";

>> String first = "coding";


변수선언 또한 한번에 할 수 있음.

String a;

String b;

>> String a,b;



< 22 >

변수를 사용하는 이유 : 중복제거를 위해.

중복을 제거하게 되면 >> 가독성이 올라가고 유지보수가 올라간다.




< 23 >

주석 comment,은 로직에 대한 설명이나 코드를 비활성화 할 때 사용.

한줄 주석 : // (같은 줄을 모두 주석화함)

여러줄 주석 : /* ~ */ (이 사이에 있는 모든 줄을 주석화함)

JavaDoc주석 : /** ~ */ 자바의 문서를 만들 때 사용. 프로그래밍적으로 해석되서 문서화함.


세미콜론이란 문장의 끝을 의미한다. 사용하지 않으면 에러가 발생함.

한줄에도 여러개의 문장을 쓸 때에 세미콜론을 통해 문장을 구분한다.



< 24 >

데이터의 크기

bit 프로그래밍에서 가장 작은 단위.

1 bit가 8개 모이면, 1 byte가 됨.

1 byte가 1024개 모이면, 1 kilobyte가 됨.

< 25 >

1byte에는 128이 들어갈 수 없음.

128을 표현하기 위해서는 short를 써야함.

byte 는 -128~127

작은 데이터를 사용할 때는 byte, 큰 데이터는 long

이렇게 맞게 사용하는 이유는 메모리의 사용을 절약할 수 있다.


* 변수가 가리키는 것이 중요한게 아니라 데이터타입이 메모리의 할당량을 결정

정수는 int , 실수는 float, double을 사용



< 26 >

상수란, 변수는 변하는 값을 의미. 그 대척점에 있는 것이 상수.

즉 constant 변하지 않는 값을 의미.

변수도 data type이 있고, 상수도 data type이 있다.

보통 실수는 double을 사용하고 float를 사용하고 싶을 경우 소수 뒤에 F를 붙임.



< 27 >

형변환 : Type Conversion 데이터의 타입을 변경하는 것.

정수 200을 int와 float으로 따로 저장하면 전혀 다른 bit 값으로 저장됨.

double a = 3.0F; 이것은 double 타입의 변수 a에 float타입의 값을 대입한다는 뜻.

이 때 3.0F의 값은 자동으로 double타입으로 형 변환이 일어남.

byte > short

char > int > long > float > double 순으로 형변환 가능.


암시적 형 변환 이유 : 정보적 손실을 줄이기 위해.


< 28 >

명시적 형변환 : 수동으로 직접 형변환 하는 것.

float a = 100.0; >>오류 왜냐하면 100.0은 double 에 들어가야 되는데 오류

int b = 100.0; >> 오류 왜냐하면 실수를 int에 못 넣음


float a = (float)100.0;

int b = (int)100.0F; 오류해결


< 29 >

연산자 operator 특정한 작업을 하기 위한 기호.

산술 연산자 : 숫자를 셀 때 사용. 더하기 빼기 곱하기 나누기.

% 나누고 난 나머지를 뜻함.


< 31 >

단항 연산자는 좌항과 우항이 있지 않는 연산자.(+ - ++ --)

++i 는 I에 1을 더한 값을 출력하라

I++는 그 줄의 출력이 끝나고 1을 더하라.



< 33 >

비교와 Boolean

Boolean이란, 참과 거짓을 의미하는 데이터 타입. true와 false 두가지의 값을 가짐.

1 == 2 : 좌항과 우항의 값이 같냐 ? 라는 의미. flase 리턴

1 == 1 : true 리턴

!= 같지 않냐 ? 라는 의미. (!는 부정을 의미)

1 != 2 : true 리턴

1 != 1 : flase 리턴


.equals는 문자열을 비교할 때 사용하는 메소드.

ex) System.out.println(a.equals(b));



< 34 >

조건문은 주어진 조건에 ᄄᆞ라서 애플리케이션이 다르게 동작하도록 하는 것.

if(true){} 일 경우에는 {}사이의 작업 실행

if(flase{} 일 경우에는 {}뒤에 것 실행.



< 35 >

if(flase){1} else {2} : 2를 실행.

else를 사용하게 되면 여러개의 조건문을 실행시킬 수 있음.

else if 는 중간에, else는 맨 마지막에 사용.

< 37 >

if 안에 else를 쓰는 이유는 하나의 문법안에 공집성을 갖기 위한 것.

하나의 if 만으로도 연관되어 있는 로직들을 같이 연결시킬 수 있음.

>> 논리연산자


< 38 >

if문을 이용해 switch문을 완벽히 대체할 수 있음.

switch()이 괄호 안에는 어떠한 값이 들어감. 그리고 case 1: 2: 이러한 것들이

중괄호 안에 위치하게 됨.

switch() 이 소괄호에 있는 숫자에 따라서 실행되는 문이 달라짐.

만약, switch안에 1이 있고 case1만 실행시키고 싶다면, case1 문 마지막에 break;를 넣어줌.

switch문과 if문은 서로 대체 가능.


default란, 조건값에 해당하는 것이 아무것도 있찌 않을 때, default 임.

swith문은 몇가지 제한된 타입만 되는데 내가 아는거는 다 되는 듯.(byte short char int)


< 39 >

논리연산자. Boolean and Boolean : and를 중심으로 좌항과 우항 다 참일 때 : 참

둘중에 하나라도 거짓이면 : 거짓

Boolean or Boolean : or를 중심으로 둘 중에 하나만 참이라도 : 참


and : &&


< 40 >

or : || 좌항과 우항중에 하나만 참이더라도 실행. 즉 둘다 거짓일 때만 실행 안 됨.


< 41 >

! : not을 의미. 역전을 시키는 역할

ex) !true : false !flase : true


< 42 >

반복문은 조건문과 더불어 중요. loop, iteration.

while(조건){반복실행영역} : 조건이 true인 동안 반복작업을 실행한다.

조건의 의미 : 언제까지

반복실행영역 : 반복작업


< 43 >

for문은 while문을 기반으로 하고, 서로 대체 가능.

while은 조건값에 대한 조건이 다 떨어져 있는데,

for문은 한 줄에 초기화, 종료조건 반복실행를 쓸 수 있음.

for(초기화; 종료조건; 반복실행){반복적으로 실행될 구문}

< 45 >

반복작업을 중간에 중단시키고 싶다면 break를 쓰면 된다.

반복이 실행되는 곳에 기준값에 대한 설정을 해놓고 break를 쓰면 그 반복문을 벗어날 수 있음.

{} 중괄호 안에 들어가는 줄이 한 줄 일 경우에는 생략 가능.

즉, 언제어디서든지 반복문을 종료시키기 위해 사용.


continue는 반복문을 실행 도중, continue를 만나게 되면 continue 밑에 줄을 실행 시키지 않고, for문으로 올라가게 됨.



< 47 >

배열이란 연관된 정보를 배열하는데 사용. 변수 안에는 하나의 데이터만 들어갈 수 있다.

반이 있다고 치자, 필요에 의해 반에는 대표를 뽑고, 반장, 부반장이라는 감투를 둔다.

선생님이 반에 들어왔을 때 반장만 불러도 어떠한 지시를 내릴 수 있다.

반장이 어디 가더라도 다른애가 반장이 돼서 어떠한 지시를 내릴 수 있다.

반장이라고 이름 붙인 것이 변수 / 반 : 프로그램 / 반장아닌애들 : 상수

배열을 쓰는 이유는 데이터들을 잘 관리하기 위해. 호출하기에도 편함.


< 48 >

배열은 연관된 데이터들을 모아서 관리하기 위한 데이터타입.

변수는 하나의 데이터를 저장. 여러개의 데이터를 저장 > 배열

< 49 >

배열 안에 숫자는 index라고 함.

배열은 주소가 0부터 시작함. 그리고 배열에 들어가는 값들을 원소(element)라고 함.

컴퓨터는 카운팅을 0부터 함.

원소들은 {}중괄호 안에 정의함.

new String[4] >> new는 나중에 배우는데, 배열을 정의할 때, 새로운 것을 만들 때

new를 쓰게됨.


배열의 크기를 만들 때는 []대괄호를 씀.

ex) String[4] >>배열의 크기 4(0~3)을 의미.


length라고 클래스 변수뒤에 적어주게 되면, 변수에 담겨있는 값이 몇 개 있냐가 아니라

몇 개의 값을 수용할 수 있느냐를 나타나게 해준다.




< 50 >

일반 학생들이 상담 받는다고 하면,

1. 학생들은 번호 순으로 정렬해서 줄을 세운다.

2. 상담받은 학생의 숫자를 기록한다.

3. 대기중인 학생과 상담을 한다.

4. 상담받은 학생의 수를 1 증가시킨다.

5. 총원이랑 상담받은 학생의 수랑 같다면 종료.

>＞배열과 반복문이 어떻게 조합되느냐를 의미.


< 51 >

for-each

for문을 좀 더 간편하게 사용할 수 있는 방법.

원소들을 e를 통해서 하나씩 가져올 수 있음.



< 52 >

String[] members = {"최진혁", “최유빈”, “한이람”};

System.out.println(members[3]);

>> 에러가 발생 / 예외를 배운 후 설명.


50명을 수용할 수 있는 교실에서 51이 되는순간 수용할 수 없다.

공간을 효율적으로 사용하기 위해서는 합리적인 수준에서의 공간을 만들어야한다.




< 53 >

메소드 : method 함수. function

메소드가 갖는 의미는, 웅장하고 결함이 없고 유지보수가 쉬운 애플리케이션을 만들기 위한 기법들이라고 할 수 있다. 일종의 관리도구.

public static void main(String[] args){ numbering(); }

여기서 main이라고 하는 것이 method임.



< 54 >

메소드의 정의와 호출

정의 : define 만드는 것 / 호출 : call

ex) numbering이라는 함수 호출 방법 : numbering();

numbering이라는 함수 정의 방법 : numbering(){ 정의하는 내용 }



< 55 >

main 이라고 하는 것은 약속을 의미.

자바 - 개발자 사이의 약속.

하고자 하는 작업이 있다면, public static vid main이라는 메소드를 정의해서 메소드의 본문에 우리가 하고자 하는 작업을 위치시키기로 약속.

메소드를 사용하면, 코드의 양이 절약되고, 유지보수를 잘 할수 있다.


< 56 >

메소드의 핵심적 가치 : 재활용성

똑같은 기능을 가진 것들을 또 만들 필요가 없음.

매개변수와 인자 : 입력값

입력값에 따라 출력값이 달라지게 된다.

입력값을 수용하기 위한 것 : 매개변수

매개변수에 값을 넣어주는 것 : 인자


< 57 >

메소드의 출력 : return / 돌려준다 의 의미. / 메소드 안의 출력값을 밖으로 돌려준다.

ex)　String result = numbering(3, 5);

output += i; >> output = output + i;를 의미

return 이 오면 무조건 반복문을 종료시키고, return뒤에 오는 값을 그 메소드 밖으로

리턴된다.

void : 메소드 이름 앞에 붙게되면, 메소드의 리턴값은 존재하지 않는다. 의미





< 58 >

메소드의 부품으로써의 가치를 높이기 위해 메소드값을 리턴해야한다.


< 59 >

메소드 안으로 들어오는 정보 : 입력

밖으로 나가는 정보 : 출력

메소드는 작은 프로그램이라고 볼 수 있다.

마우스, 키보드 >> 입력 // 모니터 스피커 출력 >> 출력


< 60 >

public static void main(String[] args) :


args에는 문자열의 값이 들어갈 것이고 배열이다.

main이라는 메소드에 매개변수로 String[] args가 들어간다.

void라서 리턴값은 없다.

main은 자바가 알아서 실행시켜주기 때문에 프로그램의 시작점이라고 할 수 있다.

< 62 >

자바앱이 실행되고 있는 동안에 사용자의 입력을 받는 방법:

scanner를 이용하면 사용자의 입력을 잡을 수 있다.

입력에 대한 이해를 폭 넓게 해야함.

Scanner sc = new Scanner(System.in);

>> System.in 에는 사용자가 입력할 값이 들어감.



< 64 >

try-catch 는 예외라고 하는 것.

File file = new File("out.txt");

>>File이라는 객체를 설정

파일이라는 데이터 자체도 유입이라는 데이터가 될 수 있다.


GUI : 그래픽유저인터페이스

그래픽하지 않은 것은 : 문자적인 것.(CLI)

GUI는 텝도 있고 닫는 버튼도 있는 시각적으로 정보를 표시하는 것.



< 65 >

자바를 크게 나누면 절차적 프로그래밍과 객체지향 프로그래밍으로 나눔.

절차지향 프로그래밍은 아주 오래된 스타일. 하지만 기본적인 것.

자바는 객체지향적인 언어이다.

오랜시간동안의 시간투자가 필요하다.



< 66 >

객체지향 프로그래밍 : Object Oriented Programming / OOP

객체지향프로그래밍의 핵심적인 것은 객체라고 하는 것. OBJECT

객체란 무엇인가?

로직을 상태와 행위로 이루어진 객체.

조금 더 구체적으로 생각하자.

하나의 프로그램은 여러 가지의 목적을 가지 로직으로 이루어진 집단.

객체에는 각 목적에 맞는 변수와 메소드가 들어가 있다.

ex) 어떤 홈페이지에는 글목록, 본문, 댓글이라는 객체가 있고,

각 객체 즉 본문 댓글에도 각 객체에 맞는 변수와 메소드가 포함되어있다.


< 67 >

설계 : 현실에서 우리가 관심이 있는 것을 소프트화 시키는 것.

현실은 생각보다 복잡하고 소프트웨어는 생각보다 간단.

설계는 추상화 과정을 거치게 됨.

추상화라는 것은 해결해야 하는 현실적 문제를 해결하기 위한 것.



< 68 >

옛날 컴퓨터는 모니터, 본체, 마우스, 키보드 중 하나만 고장나도 전체를 바꿔야 했음

하지만 지금에는 각각의 부품들을 부품화 함으로써 하나가 고장났다고 하면 그 부품만

고침으로써 옛날의 단일화의 모습을 벗어나서 여러개의 부품으로 구성되어 있는 시스템으로

바뀌게 됨.

연관되어있는 것들을 묶는 것 : 부품화, 캡슐화 (재활용성 높아짐)

제대로된 부품이라면 그것이 어떻게 만들어졌는지 모르는 사람도 사용할 수 있어야함.

(내부의 동작방법을 단단한 객체안에 숨기고 사용자에게는 메소드의 노출만 하고있는 것)

>> 정보의 은닉화, 캡슐화

잘만들어지 부품이라면 부품과 부품을 교환할 수 있어야 한다. : 인터페이스



< 69 >

클래스와 인스턴스 그리고 객체

객체를 프로그래밍적으로 만들기 위해서는 클래스와 인스턴스로 객체를 만들어야함.

클래스라는 것은 객체를 만들기 위한 설계도.

인스턴스는 설계도를 따라서 만들어진 구체적인 제품.

중복을 제거하기 위해서는 메소드를 사용해야함 >> 리펙토링

리펙토링 : 코드의 내용을 수정해서 코드를 효율적으로 만드는 행위.

자주 refactoring하는 코드가 건강한 코드임.



< 71 >

연관되어 있는 부분을 메소드화 시키면 호출할 때마다 한번에 호출 가능.

그 메소드안에는 sum함수와 avg함수가 있는데 어떤 때는 메소드 전체 호출이 아니라

하나의 함수만 실행시키고 싶을 때가 있음.


< 72 >

인스턴스는 구체적인 객체를 의미.

구체적인 객체를 만들기 위해서는 그 객체의 정확한 정보 필요.(메소드)

class Calculator : 클래스 Calculator의 정보를 알려주겠다.

this는 인스턴스 그 자신을 의미.

< 73 >

Calculator : 클래스

객체 만드는 방법 : 인스턴스 (new Calculator();)

각 인스턴스에는 변수가 각각 만들어짐.

하나의 클래스에서 두 개의 인스턴스가 만들어졌다고 하면 동작하는 방법은 같지만

상태는 다를 수 있음.(변수의 상태 등등)

객체라고 하는 것은 로직을 상태와 행위로 이루어져 있음.

객체가 가지고 있는 변수가 객체가 가지고 있는 상태임.

그 상태를 바탕으로 객체에게 메소드를 호출.

Calculator c1 = new Calculator();에서 Calculator은 데이터타입을 의미.


< 74 >

클래스가 설계도라고 한다면, 인스턴스는 설계도에 따라 만들어진 제품을 의미.

인스턴스와 인스턴스를 구분하는 기준은, 인스턴스에 들어가 있는 변수값에 따라 달라짐.

클래스의 멤버는 그 클래스의 구성원.


< 75 >

계산기에서 원주율을 알아내는 예시.

static뒤에 변수가 붙으면, 그 변수의 값은 static한 값을 가지게 되고, 이것은

클래스에 정의하는 것이기 때문에, 모든 인스턴스에서 그 변수의 값은 동일하게 저장됨.

클래스 변수의 용도:

1. 인스턴스에 ᄄᆞ라서 변하지 않는 값이 필요한 경우

2. 인스턴스를 생성할 필요가 없는 값을 클래스에 저장하고 싶은 경우.

3. 값의 변경상황을 모든 인스턴스가 공유해야 하는 경우


< 76 >

1.인스턴스 메소드는 클래스 멤버에 접근할 수 있다.

2. 클래스 메소드는 인스턴스 멤버에 접근할 수 없다.

우리들은 클래스를 만들고 인스턴스를 만들게 되는데, 클래스를 만들고 인스턴스가 만들어 진

지도 모를수 있기 때문에, 접근할 수 없다고 이해할 수 있고, 인스턴스를 만들었을 경우에는

무조건 클래스가 만들어져있기 때문에 접근할 수 있다라고 이해하면 된다.

static이 붙어있으면 클래스 메소드, 클래스 변수이다.

인스턴스 변수 > Non-Static Field

클래스 변수 >Static Field


< 77 >

변수와 메소드 같은 것들을 사용할 수 있는 것은 이름이 있기 때문.

int left;

public void sum(){}

여기서 left는 변수의 이름이고, sum은 메소드의 이름이다.

프로그램이 커지면 여러 가지 이유로 이름이 겹칠 수 있다. >> 해결방안(유효범위라는 개념)

메소드 안에서 변수를 선언하면 그 변수는 메소드 안에서만 유효하게됨.

다른 언어들은 메소드안에서도 변수를 선언하게 되면 프로그램 전체에 영향을 끼치게 되는데,

자바에서는 메소드안에서 선언된 변수는 그 메소드 안에서만 영향을 끼침.


< 79 >

어떤 파일을 만들었는데 이미 있는 이름이라면 다른 이름으로 수정해야함.

>> 디렉터리를 도입.

디렉토리 안에서는 다른 이름을 써야하지만, 디렉토리 밖에서는 상관없음.

변수에는 전역변수와 지역변수가 있다.(전역:global / 지역 : local)

클래스 바로 아래에서 변수를 선언하게 되면 전역임.

static 메소드 안에서 선언하면 지역.


< 80 >

정적인 유효범위 : static scope

동적인 유효범위 : dynamic scope


< 81 >

지역변수가 전역변수보다 우선순위가 높음.

만약 전역변수와 지역변수가 동시에 호출된 경우에는 지역변수의 선언이 메소드안에

있다면, 지역변수의 선언값을 가지게됨.

this란, 전역변수의 값을 가리키게 됨.

유효범위란, 전역과 지역으로 나누어서 관리하기 편하게 하기 위한 것.


< 82 >

초기화는 어떠한 일을 하기전의 준비단계

생성자는 객체에서 초기화할 수 있게 해주는 기능.

어떠한 클래스에 똑같은 이름의 메소드를 설정해주면, 생성자를 만드는 방법임.

생성자 : Constructor

생성자가 하는 역할은 클래스가 생성될 때 클래스와 같은 이름을 가지고 있는 메소드가

어떠한 메소드보다 먼저 실행되서 그 클래스가 가장 먼저 일을 해주게끔 설정되어있다.

만약에 똑같은 이름의 메소드를 안 만들어있으면 자동적으로 만들어줌.

생성자 만드는 예시) Calculator c1 = new Calculator(10,20);


< 83 >

상속이란 것은 어떠한 것을 물려주는 것.

어떠한 객체가 있을 때 그 객체의 변수와 메소드를 다른 객체가 물려받을 수 있도록 하는 것.

어떠한 객체가 있을 때 그 객체에 어떤 메소드를 추가하는 것은 어려울 수 있다.

>＞그 객체를 자신이 만들지 않았다. 이러한 경우에는 추가가 어렵다.

즉, 기존의 객체를 그대로 유지하면서 어떠한 기능을 추가하기 위해 상속을 사용한다.

객체를 물려주는 의미에서 부모객체가 되고, 기존의 객체의 기능을 물려받는 새로운 객체를 자식객체라고 한다.

부모클래스를 상위클래스라고 하고, 자식클래스를 하위클래스라고 표현한다.



< 84 >

상속하는 법

class SubstractinableCalculator extends Calculator

이것은 상위클래스 Calculator를 Sub~가 확장하고 있다.

< 85 >

A클래스 extends B클래스 : A클래스는 B클래스를 상속받는다.

또한 B클래스의 정보뿐 아니라 다른 기능들을 추가시킬 수 있다.

그리고 A클래스를 다른 클래스가 또한 상속받을 수 있다.

즉 그 클래스는 A와 B의 기능이 다 담겨져 있는 것.


< 86 >

생성자는 객체를 생성한다.

클래스를 만들고 그 클래스의 이름과 같은 생성자를 만든다고 할 때 인자가

들어가게 되면 실행이 안 된다.

자바에서는 클래스의 이름과 같은 생성자를 만들 때 선언하지 않았을 때는 자동적으로

그 클래스와 이름이 같은 생성자가 만들어지는데, 이 생성자는 매개변수가 없는 생성자이다.

그래서 만약 따로 선언하지 않고, 매개변수가 있는 생성자를 호출하게 된다면 오류가 발생한다.


< 88 >

overriding : 재정의, 새롭게 정의한다.

상속이라고 하는 것은 부모클래스가 있고, 자식클래스가 있을 때 부모에 있는 특정한 변수나

메소드를 자식이 사용할 수 있게 하면서 자식에 어떠한 기능을 추가할 수 있는 것.

근데 overriding은 부모로부터 상속을 받았지만, 부모클래스의 함수들을 변형시키는 것을 말함.

변형시키는 방법은 부모클래스에 있는 것 형식 그대로임.


< 89 >

override하는 것 중에는 조건이 있는데.

부모클래스의 메소드 타입과 변형시킬려고 하는 메소드의 자식클래스의 메소드 타입이 일치해야한다. 또한 매게변수의 타입도 똑같아야 한다. 즉, 부모클래스에서 A라는 메소드를 오버라이딩 할려고 한다면, 자식클래스에서도 A메소드에 대한 타입과, 매게변수, 순서가 같아야 한다.

이것이 부모클래스의 서명(signiture)이 자식클래스와 같아야한다는 것을 의미.

부모클래스의 메소드의 로직을 자식메소드에서 중복되지 않게 할려면,

super를 쓰면 되는데, super은 super가 들어있는 클래스의 부모클래스를 뜻함.

super.메소드(); 이런식으로 쓰면됨.


< 90 >

overoading(오버로딩) : 클래스에 메소드를 정의할 때 같은 이름이지만, 서로다른 매게변수의 형식을 가지고 있는 메소드를 여러개를 정의할 수 있는 방법을 말함.

A메소드와 A메소드가 있는데 두 메소드의 매게변수의 형태가 다르다면 가능한 호출이다.



< 91 >

메소드의 이름이 같고, 매게변수의 형태가 같지만 타입이 다르다면 오버로딩이 가능할까?

>>불가능. 리턴값만 다른 것은 오버로딩이 될 수 없다.

< 92 >

클래스의 경로를 지정해서 자바가 필요로 하는 클래스를 로드할 수 있도록 지정해주는 것.



< 94 >

자바를 사용할 때 클래스를 사용하는데, 클래스가 어디 있나 지정하는 것.

어떤 프로그램을 만들 때는 여러사람들과 만듬. 그런 경우에 다른사람이 만든 클래스를 자신이

만들고 있는 클래스로 옮기기 위해서는 경로를 지정해야함.

컴파일할 때마다 클래스를 지정하는건 힘듬. >> 환경변수를 이용해서 path 지정.

운영체제안에 어디에 있던 접근할 수 있는 변수 : 환경변수


< 95 >

패키지란 여러개의 클래스가 존재할 때, 동일한 이름의 클래스를 가질 수 있는데 이러한 문제를

어떻게 해결할 수 있을까 하는데의 중복의 문제를 해결하기 위한 것.

java.txt를 A디렉토리와 B디렉토리에 각각 저장하면 java.txt의 파일이 중복적으로 있을 수 있다.


< 96 >

properties를 누르면 해당 클래스의 location을 알 수 있다.

src란 소스코드들을 저장하고 있는 디렉토리.

그 뒤에는 파일이 위치하고 있는 디렉토리.

즉, 패키지란 일종의 디렉토리 개념.

import란 소속되어있는 패키지가 아니라 다른 패키지로부터 기능들을 가져올 때 씀.

< 97 >

손 컴파일 : 개발도구 없이 코딩하는 경우는 거의 없으나, 알아두면 좋다.

디렉토리 구조에서 bin은 binary 의 약자 / src는 소스코드가 들어가있음.

즉. bin은 컴퓨터가 이해하는 것. src는 사람이 이해하는 것.


< 98 >

이름의 중복을 회피하지 못할 때도 있다.


< 99 >

API . API문서 보는 법

ex) System.out.println();

앞에 이름이 나오고 ()사이에 숫자가 들어가면, 메소드가 실행된다는 의미.

그럼 println은 메소드임.

그럼 System은 클래스 / out은 System클래스의 멤버 중의 변수.

그럼 println은 사실 out에 담겨져 있는 객체이다.

API란, 자바시스템을 제어하기 위해서 자바에서 제공하는 명령어들을 의미.



< 100 >

UI : User Interface

API : Application Programming Interface

UI는 사용자와 접하는 지점. / 노트북 입력 / 스피커 출력 등 / 홈페이지의 메뉴판


< 101 >

자바프로그래밍을 한다는 것은 API를 조작하는 것이다.

예를들어, println()에는 괄호안에 들어가야할 다양한 타입이 이미 정의되어있다.

ᄄᆞ라서 우리는 그것을 가져다 쓰기만 하면됨.


< 102 >

접근제어자는 권한에 차등을 주어서 메소드를 차별적으로 주는 것.

추상클래스, final, 접근제어자, 인터페이스등은 규제에 해당하는 것.

사용하는 사람 입장에서는 안심하고 변수와 메소드를 사용할 수 있게끔 해줌.


< 103 >

클래스에 public / private

public이면 누구든지 그 메소드를 불러서 사용할 수 있다.

하지만. private면 그 클래스 내부적으로는 사용할 수 있지만, 그 외부에서는 사용할 수 없다.


< 104 >

접근제어자를 사용하는 이유는, 은행이있고, 하나의 객체라고 생각하자. 그럼 고객이 있다.

은행에는 창구가 있는데, 창구에서는 고객들과 만나게 된다. 여기서 창구가 public이라고 한다면, 돈이들어있는 금고는 private이다. private는 특별한 권한을 가진 사람만 접근하게된다.

이것이 구분되어있는 이유는, 시스템을 좀 더 안전적으로 보호하기 위한 것이다.

따라서 적은 메소드들로 프로그램을 진행시킬 수 있다.


< 105 >

기억해야할 것은, public은 아무대서나 접근가능, private는 그 클래스내에서만 가능.

접근제어에는 4가지가 있다.

private , default, protected, public

아무것도 선언 안하면 default임.

private는 같은 클래스가 아니면 접근 안됨.

다른패키지면서, 상속관계도 아니면 public빼곤 접근 불가.

같은 패키지면 다 접근가능.

다른패키지면서 서브클래스면, protected는 되지만 default는 되지 않는다.


< 106 >

클래스의 접근 제어자는 두 개의 접근제어자만 가지고 있다. default와 public

접근제어자가 public이면, 다른패키지의 클래스에서도 사용가능하지만,

default면, 같은 패키지에서만 접근 가능하다.

< 107 >

abstract 추상화

abstract로 지정되어있는 것은 직접적으로 사용할 수 없고, 상속해서 사용해야함.

다시말해서 상속하도록 강제하는 것.

추상화시키는 과정은 클래스 앞에 abstract를 쓰면 됨.

추상화된 A클래스안에 b라는 메소드도 추상화 되어있다면, 추상적인 메소드이다.

추상화된 메소드를 사용하기 위해서는, 오버라이딩을 해야함.


< 108 >

부모클래스는 메소드의 시그니처만 정의해놓고, 그 메소드의 실제 동작 방법은 이 메소드를

상속 받은 하위클래스의 책임으로 위임한다.

상황에 따라서 동작하는 방법이 달라져야 하는 것은 사용자에게 위임한다.

공통적인 것은 클래스가 위임하고 특정한 동작은 사용자가 직접 설정한다.


< 109 >

디자인패턴은 프로그래밍의 설계를 뜻하고 패턴은 반복적인 행동을 뜻함.

그러한 패턴들에 이름을 부여해서 정리해 놓은 것.

어떠한 패턴이 있는데 그것을 정리해놓지 않으면, 일일이 패턴이 있을 때마다 다 설명을

해야함. 이러한 것을 해결하기 위해 디자인 패턴을 정리해 놓아야 함.

이러한 개발 방법을 template pattern이라고 함.


< 110 >

final이란 상속이나 변경을 규제하는 것.

final로 선언한 것은 바꿀 수 없다.

즉, 고정하는 것을 말함.


< 111 >

인터페이스를 규제라는 측면에서 알아보자.

어떤 클래스가 있고, 그 클래스가 특정한 인터페이스를 사용한다면 그 클래스는 반드시

인터페이스에 포함되어 있는 메소드를 포함하는 것을 강제하는 것.



< 112 >

만약 두명의 사람이 각각의 클래스를 맡아서 작업을 한다고 하면,

인터페이스를 이용하여서 가짜 클래스를 만들어 미리 작업해놓고, 나중에

그 작업한 것들을 합치게 되면 시간을 효율적으로 사용할 수 있다.


< 113 >

인터페이스는 그 대상이 되는 시스템을 제어하기 위해서, implements를 씀.

접근제어자는 반드시 public이어야 함.

하나의 클래스는 복수개의 인터페이스를 구현할 수 있다.

또한 인터페이스 또한 상속이 가능.

abstract vs interface

abstract클래스는 특정한 메소드를 하위클래스가 상속받아서 사용하도록 강제.

interface는 본체가 있는 메소드들만 사용해야함.


< 114 >

다형성이란, 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미.

키보드에는 여러개의 키가 있는데, 키보드의 키를 비유해보면, 엔터키를 누르면 실행이지만

esc를 누르면 취소의미. 누르는건 같지만 의미가 다르다.

오버로딩이란 같은 이름이지만 매개변수나 타입에 따라 같은 이름이지만 다르게

동작하는 것을 의미하는데, 오버로딩은 다형성의 예가 됨.



< 116 >

두 개의 객체가 동일한 데이터 타입으로 존재하면서 각각의 클래스에 정의되어있는 메소드를 호출할 때는, 각각의 클래스에 저장되어 있는 메소드로 동작하는 것이 다형성의 특징.



< 118 >

하위클래스를 인터페이스화 시킬 때 그 인스턴스화된 변수의 데이터타입으로 그 클래스가 구현되어 있는 것을 지정할 수 있다.

< 119 >

사람은 다면적인 존재이다. steve라는 사람이 있으면, 직업이 아버지이고 프로그래머고 신도일 수 있다 rachel은 엄마이고, 프로그래머이다.

이처럼, 코드에서도 한 클래스가 다양한 인터페이스를 구현할 수 있다.

동일한 방식으로 사용하지만, 실제로 코딩을 요청했을 때 같은방식이지만 서로 다른 결과물을

만들어 내는 것이 다형성이다.


< 120 >

예외라는 것은 프로그램에서 발생하는 오류를 처리하는 법.

오류 이러한 것들은 부정적인 느낌을 갖게 한다. 애플리케이션이 잘 동작하게 되면

이러한 것들이 상관이 없지만, 동작하는데 있어서 실패가 있다면 오류가 중요하다.

예외, 보안 이것들은 성공하는 법이라는 것을 알아야한다.


< 121 >

예외란, 오류와는 다르다. 오류라고 하는 것은 예외의 일종이다. 애플리케이션을 구축하는

과정에서 기획이 있을 것이다. 이러한 기획하에 애플리케이션을 만들게 된다.

여러 가지 이유로 인해서 예상하지 못했던 상황이 발생하게 되면 이러한 것들을 예외

exception이라고 한다. 예외상황을 처리하고 돕는 방법을 예외라고 한다. 또는 예외처리라고 한다.

try는 무엇을 시도해본다. / catch 는 무엇을 잡는다.

오류가 발생할 수 있다고 예측되는 부분을 try{}사이에 위치시킨다.

만약 try안에서 오류가 발생하면 catch{}부분이 실행되게 된다.

< 122 >

예외가 발생했을 때 뒷수습 하는법, 하지만 제대로된 수습은 어렵다.

그저 기본적으로 제공하는 뒷수습의 방법만 알아보자.


< 123 >

에러에는 여러 가지가 있는데, 각 예외마다 처리하는 방법이 다르다.

arrayindexoutofbound / artismatic exception

각 예외마다 다르게 처리하고 싶다면, catch문으르 사용하여서 catch() 안에다가

각 예외의 경우를 쓰고 각 예외마다 다르게 처리할 수 있다.



< 124 >

언제나 try와 catch뒤에 finally가 와야지 다른 문법에 들어가게 되면 오류.

finally란, 예외여부와 관계없이 실행되는 로직을 말함.

DB란 데이터를 저장하고 있는 서버이다. 자바 어플리케이션이 DB에 접속해서

어떠한 정보를 가져오게 되는데, 정보를 가져올 수 있는 어플리케이션의 수가

한정되어있다. 어떠한 작업을 하는 과정에서 DB와 어플리케이션의 접속을 꺼줘야

하는 경우에는 문제가 생길 수 있다. 이때에 DB와 어플리케이션의 연결을 강제적으로

끊어줘야 되는데, 그러한 경우에 FIANLLY를 쓰게된다.



< 125 >

예외라고 하는 것은 일종의 폭탄이다. 이러한 폭탄은 다른사람에게 던질 수 있고 자기가

해결할 수 있다.

FileReader :　파일을 읽기 위한 객체

ex) new FileReader("out.txt")

예외를 던지게 되는데, 이러한 예외를 처리하기 위해 try, catch,를 썼음.

API사용자인 우리에게 예외를 처리하기 위해서 우리는 catch함

API는 우리에게 던진것이고 우리는 잡았다는 얘기.

API가 우리에게 던졌다면 우리는 그것을 잡을 수 있지만 그것을 우리는

또한 잡지않고 다른사람에게 던질 수 있음.


< 126 >

다른사람에게 예외를 던지는 것을 배울 것임.

ThrowExceptionDemo를 이용해서 다른사람에게 예외를 넘길 수 있음.


< 127 >

FileNotFoundException이라는 것을 사용해야함.

우리가 run이라는 메소드에 위의 것을 throw를 한다는 것은 run을 사용하는

사용자에게 강력한 암시를 주는 것이다.

예외는 중첩적으로 사용할 수 있다.


< 128 >

예외를 사용하는 사용자 입장에서, API를 만드는 과정에서 예외를 발생시키고

어떻게 처리할 것인지 결정하는 것.

어떠한 예외를 처리하는 과정을 알아보자.

부적합한 인자를 사용하게 되면 예외가 발생하는 경우가 있다.


< 129 >

어떠한 예외처리에 있어서 어떤 것은 예외처리를 반드시 해야하는 것이 있고,

어떤 것은 안해도 되는 것이 있다.

여기서 말하는 것은 예외처리하면 오류가 뜨는 것이 있고 안해도 안뜨는 것이

있다는 얘기이다.

< 130 >

클래스를 인스턴스화 시켜서 전달할 때 예외클래스를 보자.

Object는 모든 클래스에 시조가 되는 객체.

그 밑에 Throwable 이라는 클래스 아래에서 작업을 했기 때문에

우리가 Throw를 할 수 있었다.

Throwable 클래스 아래에는 Error과 Exception이 있다.

즉 Throwable은 모든 예외의 부모.

다시말해, checkedexception은 그 예외를 처리하는 예외처리가 반드시

존재해야한다.

uncheckedexception은 예외를 처리하지 않아도 된다.

Exception을 처리할 때 예외를 반드시 해야하는가 안하는가를 보는 것이 중요.



< 131 >

기본적으로 제공하는 예외 클래스들 > 표준예외라고 함.

기본적으로는 표준예외클래스를 사용하는 것이 좋고, 만약 표준예외클래스에

자신이 원하는 것이 없을 때만 자신이 필요로하는 예외클래스를 직접 만듬.

우선 checked 인지 unchecked인지 아는 것이 중요.


< 132 >

Object클래스는 모든 클래스의 조상이라고 할 수 있다.

모든 클래스들의 공통된 조상.

class O{} 는 class O extends Object{}와 같은 의미.

각각의 클래스들이 가지고있어야 하는 공통적인 기능을 제공.



< 133 >

toString : 문자화시킨다 / 객체를 문자로 표현하는 메소드

equals : 객체와 객체가 같은것인지 비교하는 API



< 135 >

finalize : 객체가 소멸될 때 호출되기로 약속된 메소드이다.

사용하는경우가 많지 않다.

원시데이터형에 해당하는 데이터타입들을 사용할 때는 비교연산자를 쓰고,

객체를 사용할 때는 equals쓰면 된다.

garbage collection이란 인스턴스를 만드는 것은 내부적으로는 컴퓨터의 메모리를

사용하는 것인데, 여기서 메모리란 RAM을 의미한다. 어떤 프로그램을 실행시키면,

램을 통해 실행이 되는데 램이란 자원은 컴퓨터에서 가장 소중한 것임.

이것을 적게 사용하면서도 파워풀하게 작동하는 것이 좋은 어플리케이션이다.

이 렘을 효율적으로 사용하기위해서 여러 가지 방법들이 있는데, 이러한 것들을 자동화

해주는 것이 가비지 컬렉션이다. 사용하지 않는 변수를 발견하면 자동적으로 삭제.

이것이 자바의 특징.


< 136 >

clone이란 복제를 의미.

Clonable 인터페이스에는 아무것도 있지 않다. 이 인터페이스는 해당 클래스를

복제 가능한 클래스라는 사실을 자바 머신에게 알려주기 위한 구분자의 역할을 한다.

모든 클래스의 조상은 Object이다. 모든 클래스들은 오브젝트 클래스의 데이터타입으로

가질 수 있는 것들은 변수화 해서 담길 수 있다. 또한 데이터타입의 인스턴스는 원래의

클래스가 되려면 명시적으로 형변환해야하고, Object에 있는 것들으르 오버라이딩 해서

자신이 원하는데로 사용할 수 있다.



< 137 >

상수란, 변하지 않는 값을 의미. 변수와 구분할 것.

상수만을 이용해서 프로그래밍을 하다보면, 여러줄의 프로그래밍을 하거나,

주석이 지워지거나, 주석이 없거나 한다면, 해당 프로그램을 제대로 실행시킬 수 없음.



< 138 >

final이란 전역에서 어떠한 값을 강제로 정해두는 것.

앞에 접두사를 붙임으로써 비슷한 변수들에대한 값들을 정리할 수 있다.

인터페이스에서 필드를 작성하는 것은 public final static을 의미.

인터페이스에 상수를 정리해놓으면, 서로 겹칠일이 적어짐.


< 139 >

열거형은 서로 연관된 상수들의 집합.

바뀌지 않는 값들의 집합.

enum은 많은 사람들이 사용하는 패턴들을 자바에서 수용한 것.

자주 사용하는 패턴을 문법적으로 제공하는 것.

즉, 간략하게 만들어 주는 것.

또한 인스턴스의 생성과 상속을 방지한다.

< 140 >

enum이라는 것은 사실상 클래스이다.

그렇게 때문에 생성자를 가질 수 있다.

enum클래스 안에 enum과 같은 이름을 가진 생성자를 생성 할 수 있다.

enum은 열거형이다. 따라서 여러 가지 정보를 열거할 수 있다.

또한 상수들을 하나씩 꺼내서 쓸 수 있다.

열거형은 연관된 값들, 정확하게는 상수들을 저장하고 그것들이

변하지 않도록 한다. 열거형은 그 자체가 클래스이기 때문에, 클래스가 할 수 있는

일은 열거형도 할 수 있다.

열거형에 있는 상수들을 values라고 해서 상수들을 담은 배열을 가져올 수 있고

배열에 저장되어 있는 상수들 또한 사용할 수 있다.


< 141 >

참조, reference .

우선 복제라는 것은 무언가를 똑같이 만드는 것을 말하는데, 그리고 전자화된

시스템을 기존에 전자화 되어있지 않는 물리적인 세계와 구분하는 가장 중요한

특징은 복제를 하는데 시간과 자원이 거의 들지 않는 다는 것이다.

new를 이용해서 선언하는 데이터타입은 참조데이터형이다. 기본형이 아니다.

int a = 1;

int b = a;

이 말은 첫 번 째 줄에는 a라는 상자안데 1이라는 종이가 들어가 있는 것이고,

두 번째 줄은 b라는 상자안에 a라는 상자안에 들어있는 1이라는 종이가 복제되어서

담겨 들어가는 것이다.


< 142 >

하지만, 위의 결과와는 다르게 참조를 사용하게 되면 상황이 달라진다.

A a = new A(1);

A b = a;

b.id = 2;

이러한 것의 결과는 2가 나오게 된다.

기본데이터 타입을 담을수 있는 변수에 담겨져 있는 값과

new를 이용해서 만들어진 참조형 변수에 담겨져 있는 값이 다르다 라는 것을 의미.

a라는 상자와 b라는 상자가 있다. 첫 번째 줄을 실행시키면 a클래스의 인스턴스는

어딘가에 만들어지게 되는데, 클래스 a는 A인스턴스의 위치에 대한 정보를

가지고는 있다. 두 번째 줄은 a가 가지고 있는 주소값을 b가 가지게 된다.

따라서 b.id = 2 라 하면, a가 가리키고 있는 A인스턴스의 id값을 출력하게된다.

이것들을 참조, reference라고 한다.

변수의 데이터타입을 기본형으로 하면 내부적으로 복제가 일어나기 때문에 각각의

변수에 담겨져 있는 것들만 변하게 되고, 참조형으로 만들면 그 객체에 대한 주소값이

담겨져 있기 때문에, 값들이 다르게 변하게 된다.


< 143 >원본파일이 있다. 원본파일을 복사하면 복사본이 만들어진다. 원본파일을 수정하게 되면

복사본의 내용이 달라질까? 달라지지 않는다. 왜냐하면 각각 저장되어있기 떄문이다.

하지만 바로가기 라는 것을 이용해 복사본을 만들고 원본파일의 내용 수정이 이루어지면

바로가기 복사본 파일도 원본 내용수정에 따라 내용이 달라지게 된다.

바로가기란 것은 원본파일을 참조하기 때문이다. 바로가기는 원본을 가리키기 때문에

적은양의 데이터를 사용할 수 있다. 복제를 하게 되면 많은 데이터를 사용하게 된다.

즉, 같은 주소값을 가지고 있는 것들은 동일한 값을 가지고 있다.

기본형이란 것은 그 데이터를 직접 가지고 있는 것이고.

참조형이라는 것은 그 데이터를 참조 한다는 것을 의미한다.

new를 이용해서 만드는 모든 데이터타입은 참조~~이다.

참조라고 하는 것은 컴퓨터 메모리도 덜 사용하게 된다.



< 145 >

제네릭, generic 포괄적인

제네릭이란 클래스 내부에서 사용할 데이터타입을 나중에 인스턴스를 생성할 때 확정

하는 것을 말함.

제네릭은 매게변수와 비슷하게 작동한다. 제네릭은 그 변수의 데이터타입과 관련있다.

어떠한 클래스가 T라고 <>여기 사이에 쓰면서 선언한다고 해보자.

class Person<T>{}요렇게. 이 Person을 인스턴스화 할 때 String이라는 구체적인

데이터타입을 언급하게 되면, T는 string이 되고, info는 String 타입을 가지게된다.

class Person<T> { public T info;} Person<String> p1 = new Person<String>();



< 146 >

왜 제네릭을 사용할까 ?

우리는 컴파일 하는 언어를 사용하고 있는데, 컴파일 언어를 사용하는데 있어서 중요한

장점은 그 프로그래밍이 되기 전에 사용자의 실수를 검출해준다는 것이다.

유발시킬 수 있는 에러는 컴파일러과정에서 발견할 수 있어야 함.

ᄄᆞ라서 코드의 중복을 제거함으로써 좋은 결과도 있지만, 그 코드의 중복을 제거하는

과정에서 클래스안의 생성자안에 들어갈 수 있는 데이터의 데이터 타입을 object로 하면서

어떤 타입도 매게변수로 들어갈 수 있게 된다. 하지만 우리가 데이터타입을 지정하게 되면

그 데이터타입만 들어갈 수 있게끔 설정해 놓은건데 object로 하게 되면서 어떤 타입도

들어갈 수 있게 됐다. 이것이 타입이 안전하지 않다 라는 것을 의미한다.

변수에는 그 데이터 타입만이 들어가게끔 했는데 object로 하면 데이터타입에 대한 안전성이

떨어진다. 타입이 안전하다는 장점과 코드의 중복을 제거하는 편의성을 얻기 위해 도입한

것이 제네릭이다.


< 147 >

복수의 제네릭이 필요할 때는 <>안에 ,를 찍어주고, 서로 다른 이름이어야한다.

제네릭에는 기본데이터타입은 올 수 없고 오로지 참조형만 갈 수 있다.

기본데이터 타입을 마치 객체인 것처럼 만들 수 있는 객체들이 존재하는데. 그러한 클래스들을 wrapper클래스라고 한다. wrap은 포장하다라는 뜻인데, 기본 데이터 타입을 객체로

포장한다라고 생각하면 된다.

예를들어 int에 대한 wrapper클래스는 Integer이다. 이렇게 되면 기본 데이터 타입도 wrapper클래스를 이용해서 사용할 수 있다.


< 149 >

제네릭은 인스턴스화 시킬 때 클래스가 임시적으로 지정해놓은 것을 한다.

제네릭으로 오만가지의 타입들이 들어올 수 있다. 이것을 해결하기 위해 extends를 이용한다.

extends를 이용하면 타입들을 좀 제한할 수 있다.

class Employee extends Info 이렇게 쓰면

Employee는 Info나 Info클래스 이거나 Info클래스의 자식클래스들만 올 수 있도록 제한한다.

extends는 인터페이스에서도 사용할 수 있고 클래스에서도 사용할 수 있다.

extends말고도 super란 것도 있지만 super는 활용도가 높지 않다.

< 150 >

프레임웍크 : 배열이 가지고 있는 불편한 점을 해결하기 위한 것.

배열을 이용할 때는 우리가 이용하려고 하는 배열에 넣을 개수를 알때는 사용하기에

편하지만, 모를때는 어렵다.

프레임웍크를 사용할때는 몇 개의 값을 넣을지 모를 때 사용하여도 된다.

또한 배열의 크기를 알려고 할 때 length를 이용하지 않고, size를 이용한다.

여기서 값을 넣을 때 add를 이용하게 되는데, arraylist 내부에 저장할 때 object타입으로

저장을 해야한다.


< 151 >

컬렉션즈 프래임워크란 collection이라는 것과 map이란 상위의 카테고리가 있다.

이것들을 다 묶어서 컬렉션즈 프래임워크라고 한다. 그리고 성격과 기능에 따라서 set, list, queue로 나뉘어진다(collection)아래에.

또한 set, list, queue아래에도 여러 가지고 나뉘어 진다.


< 152 >

Set중에는 Hashset이 있다. 이것을 사용하기 위해서는 java.util를 import시켜야함.

Arraylist같은 경우에는 각각의 방이 생기고 우리가 넣은 값들이 각각 하나씩 들어가지게 된다. 반면 hashSet같은 경우에는 방이 생기긴 하지만 같은 값들을 넣는 경우가 생긴다면 기존의 값이 이미 방에 있다면 새로운 방이 생성되지 않는다. 즉 중복되는 값은 들어가지 않고 고유한 값만 들어가게 되는데. 이것이 Set 과 List 의 차이점이다.


< 153 >

addAll 이란 것은 합집합의 개념.

retainAll 이란 것은 A에도 있고 B에도 있는 값만 저장. 즉 교집합의 개념.

removeAll 은 차집합의 개념.

Set 과 List의 차이는 Set은 집합의 개념이기 때문에 중복되는 값은 들어가지 않고 순서적이라고 보장할 수 없다. 하지만 List는 모든 값이 들어가고 순서적이다. 가장 큰 차이점은 중복이 되냐 안되냐 순서가 보장되냐 안되냐이다.


< 155 >

iterator는 반복자로 해석하면 되는데 컨테이너에 있는 값을 하나씩 꺼내서 처리할 수 있도록 해주는 것이다. iterator는 인터페이스인데, 3개의 메소드를 가지고 있다. hasnext와 next인데 next를 통해 iterator안의 값이 사라진다고 해서 오리지널에는 값이 사라지는 것이 아니다. 이것은 set에서도 사용할 수 있고 list에서도 사용할 수 있다.


< 156 >

Map이란 것은, 원이 2개가 있다. 한 원에는 Key가 저장되고, 다른 원에는 Value가 저장된다.

Key에는 one이 저장되고 이것은 Value 의 1을 가리킨다. two는 2, three는 3 이런식.

Key값은 중복이 허용되지 않지만, Value는 중복이 허용이 된다. 만약 one에 1을 가리키도록 했다가 나중에 200을 또 one에 저장하게 한다면 1은 200으로 바뀐다.

< 158 >

Map.Entry에는 getKey()와 getValue()가 있다.

어떤 데이터를 정렬할 때는 sort를 이용해야 하는데, sort는 list형식의 데이터타입을 가지고 있고 list형식만 다루는 메소드이다. 또한 Comparable이라는 인터페이스를 implements 해야한다. int는 양수 0 음수 이 값으로 나오는데, 0을 리턴한다는 것은 현재객체와 비교객체가 같다면 0 이 된다. 현재의 객체와 object안으로 들어오는 객체를 비교했을 때 현재의 객체가 더 크다면 양수, 작다면 음수가 출력된다.